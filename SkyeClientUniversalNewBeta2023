local Notification = loadstring(game:HttpGet("https://raw.githubusercontent.com/Jxereas/UI-Libraries/main/notification_gui_library.lua", true))()
local stop = Notification.new("info", "Skye Client", "Waiting for Skye Client to load")
wait(0.5)
local stop2 = Notification.new("info", "Skye Client", "Thank you for using Skye!")
wait(2)

local Client = require(game:GetService"ReplicatedStorage".TS.remotes).default.Client
local UIS = game:GetService"UserInputService"
local KnitClient = debug.getupvalue(require(game.Players.LocalPlayer.PlayerScripts.TS.knit).setup, 6)
local sprinttable = KnitClient.Controllers.SprintController

local Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/xHeptc/Kavo-UI-Library/main/source.lua"))()
local Window = Library.CreateLib("Skye Client", "Ocean")
local SectionCombat = Tab:NewSection("Combat")
local SectionMovement = Tab:NewSection("Movement")
local SectionPlr = Tab:NewSection("Player")
local SectionWorld = Tab:NewSection("World")
local SectionVis = Tab:NewSection("Visuals")

SectionPlr:NewButton("AntiVoid", "Dont die in the void", function()
    		task.spawn(function()
			task.wait(1)
			Module.AntivoidPart.Touched:Connect(function(hit)
				if hit.Parent.Name == game.Players.LocalPlayer.Character.Name then
					for i = 1, math.round(Dropdowns.Jumps[5]) do
						game.Players.LocalPlayer.Character.Humanoid:ChangeState"Jumping"
						task.wait(0.1)
					end
				end
			end)
		end)
		repeat
			task.wait()
			if Module.AntivoidPart then
				Module.AntivoidPart.Color = getgenv().HUDColor
				Module.AntivoidPart.Transparency = Dropdowns.Transparency[5] / 100
				Module.AntivoidPart.Position = Vector3.new(100, 25 - Dropdowns.LowerY[5], 100)
			else
				local AntiPart = Instance.new("Part", workspace)
				AntiPart.Size = Vector3.new(1.999e3, 1, 1.999e3)
				AntiPart.Anchored = true
				AntiPart.Material = Enum.Material.Neon
				AntiPart.Position = Vector3.new(100, 25 - Dropdowns.LowerY[5], 100)
				Module.AntivoidPart = AntiPart
			end
		until Module.Enabled == false or Uninjected == true
		Module.AntivoidPart:Destroy()
		Module.AntivoidPart = nil
end)

SectionPlr:NewButton("AutoConsume", "Consumes anything that is consumable", function()
    local inventory =  game.Players.LocalPlayer.Character:WaitForChild("InventoryFolder").Value
		local EatConnection = inventory.ChildAdded:Connect(function(NewItem)
			if string.find(string.lower(NewItem.Name),"cone") or string.find(string.lower(NewItem.Name),"pie") then
				Bedwars.Eat:CallServerAsync({["item"] = NewItem})
			end
			if string.find(string.lower(NewItem.Name),"app") then
				task.spawn(function()
					repeat
						task.wait()
					until game.Players.LocalPlayer.Character.Humanoid.Health <= Dropdowns.AutoEatHeal[5]
					Bedwars.Eat:CallServerAsync({["item"] = NewItem})
				end)
			end
		end)
		repeat task.wait(1) until Module.Enabled == false or Uninjected == true
		EatConnection:Disconnect()
	end)
end)
SectionVis:NewButton("Chams", "Creates a FE border around everyone on your screen", function()
    local Chams = {}
		repeat
			task.wait(2.5)
			for i,v in pairs(game.Players:GetPlayers()) do
				if v.Character and Utilities.IsAlive(v.Character) and not v.Character:FindFirstChild("Highlight") then
					local Highlight = Instance.new("Highlight",v.Character)
					table.insert(Chams,Highlight)
					task.spawn(function()
						repeat
							task.wait()
							Highlight.FillTransparency = Dropdowns.FillTransparency[5] / 100
							if Dropdowns.TeamColor[3] == false and Utilities.IsAlive(v.Character) and v.Team and v.Team.TeamColor then
								Highlight.FillColor = HUDColor
							else
								Highlight.FillColor = v.Team.TeamColor.Color
							end
							Highlight.OutlineTransparency = Dropdowns.ChamsOutlineTransparency[5]/100
							if Dropdowns.OutlinesMatchFillColor[3] == true then
								Highlight.OutlineColor = HUDColor
							else
								Highlight.OutlineColor = Color3.fromRGB(255,255,255)
							end
						until not v.Character or not Utilities.IsAlive(v.Character)
					end)
				end
			end
end)
Section:NewButton("BedNuker", "Break beds without you brekaing it yourself", function()
    local raycastParams = RaycastParams.new()
		raycastParams.IgnoreWater = true

		GetBeds = function()
			beds = {}
			for i,v in pairs(game.Workspace:GetChildren()) do
				if v.Name == "bed" and v.Covers.BrickColor ~= game.Players.LocalPlayer.Team.TeamColor then
					table.insert(beds,v)
				end
			end
			return beds
		end

		local Damage = game:GetService("ReplicatedStorage").rbxts_include.node_modules.net.out._NetManaged.DamageBlock

		MainNuker = function(bed)
			local part = bed
			local raycastResult = workspace:Raycast(part.Position + Vector3.new(0,24,0), Vector3.new(0,-27,0), raycastParams)

			if raycastResult then
				local TargetBlock = raycastResult.Instance
				print(TargetBlock.Name,"Nuker output")
				for i,v in pairs(TargetBlock:GetChildren()) do
					if v:IsA("Texture") then
						v:Destroy()
					end
				end
				TargetBlock.Color = HUDColor
				TargetBlock.Material = "Neon"
				Damage:InvokeServer({
					["blockRef"] = {
						["blockPosition"] = Vector3.new(math.round(TargetBlock.Position.X/3),math.round(TargetBlock.Position.Y/3),math.round(TargetBlock.Position.Z/3))
					},
					["hitPosition"] = Vector3.new(math.round(TargetBlock.Position.X/3),math.round(TargetBlock.Position.Y/3),math.round(TargetBlock.Position.Z/3)),
					["hitNormal"] = Vector3.new(math.round(TargetBlock.Position.X/3),math.round(TargetBlock.Position.Y/3),math.round(TargetBlock.Position.Z/3))
				})
			end
		end

		repeat
			task.wait(.25)
			local Beds = GetBeds()
			for i,v in pairs(Beds) do
				if Utilities.IsAlive(game.Players.LocalPlayer.Character) then
					if (v.Position - game.Players.LocalPlayer.Character.PrimaryPart.Position).Magnitude < 28.5 then
						MainNuker(v)
					end
				end
			end
		until Module.Enabled == false or Uninjected == true
	end)
end)
